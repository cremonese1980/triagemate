# Phase 9.2 ‚Äî Durable Idempotency + Message Flow Validation

---

## üìä # STATE MARKER ‚Äî PHASE 9.2

```yaml
Change ID: TM-9.2
Branch: feat/phase-9.2-durable-idempotency

Stage: DONE (Durable Idempotency Complete)

Runtime:
  - Profile dev: OK
  - Profile docker: OK
  - Profile test (Testcontainers Postgres): OK
  - PostgreSQL-backed idempotency: ACTIVE
  - In-memory repository: REMOVED

Implementation:
  - processed_events table (event_id UNIQUE constraint enforced)
  - Atomic INSERT-first pattern (ON CONFLICT DO NOTHING)
  - Jdbc-based idempotency guard (no exists+save race window)
  - Kafka listener performs claim-before-route
  - Duplicate short-circuit before side effects
  - Restart-safe behavior verified (manual + automated)
  - Race-condition validated (guard-level + Kafka pipeline)
  - Deserialization hardening active (null + malformed handling)
  - All integration tests aligned to new claim-first contract

Pending:
  - README update (idempotency behavior section)
  - ADR update (final implementation notes)
  - Tag v0.9.2 creation

Integration status: Local green
CI status: GREEN (if verified) / TO VERIFY (if not yet executed)

Manual validation:
  - Docker cold start: VERIFIED
  - Duplicate replay after restart: VERIFIED
  - Malformed JSON resilience: VERIFIED

Completion criteria: MET (Functional + Hardening complete)
```


**Phase Lineage:**
```
v0.8.1 (Kafka Hardening) ‚Üí Phase 9.1 (PostgreSQL Runtime) ‚Üí Phase 9.2 (Durable Idempotency)
```

---

## üÖê Design Freeze

### Problem Statement
Current idempotency mechanism is in-memory (Phase 8.x). This is not:
- **Durable** ‚Äî lost on restart
- **Restart-safe** ‚Äî duplicate processing after crashes
- **Cluster-safe** ‚Äî no coordination across instances
- **Production-ready** ‚Äî synchronized maps are a stopgap

We now have (from Phase 9.1):
- PostgreSQL runtime environment
- Stable Kafka wiring
- Profile-based datasource configuration

We need:
- **Persistent idempotency storage**
- **Verified message ‚Üí decision ‚Üí DB flow**
- **Consumer resilience to malformed messages**
- **Deterministic behavior under restart**

### Solution
Implement **table-based idempotency** using PostgreSQL with unique constraint enforcement. Use Spring Data JPA for repository layer and transactional boundaries for atomic event processing.

### Explicit Scope

| In Scope ‚úÖ | Out of Scope ‚ùå |
|-------------|-----------------|
| `processed_events` table schema | Complex retry orchestration |
| JPA Entity + Repository layer | Advanced dead-letter strategy |
| E2E message ‚Üí decision ‚Üí DB flow | Observability dashboards |
| Duplicate detection logic | Multi-broker topology |
| Integration tests with Testcontainers | Performance optimization |
| Deserialization hardening | Production deployment scripts |
| Remove in-memory idempotency code | Database migration tooling (Flyway) |

### Architecture Decision

**Idempotency Strategy: Table-based unique constraint approach**

```sql
CREATE TABLE processed_events (
    event_id VARCHAR(255) PRIMARY KEY,
    processed_at TIMESTAMP NOT NULL,
    decision_id VARCHAR(255) NOT NULL
);
```

**Why this approach:**
- **Simple** ‚Äî minimal moving parts
- **Strong consistency** ‚Äî ACID guarantees
- **DB-enforced uniqueness** ‚Äî no application-level race conditions
- **No race condition window** ‚Äî constraint violation is atomic
- **Restart-safe** ‚Äî survives application crashes

**Alternatives considered:**
- **Redis** (rejected: no durability guarantee in current architecture, adds infrastructure dependency)
- **Kafka compaction topic** (rejected: higher complexity, eventual consistency, harder testing)
- **Distributed cache** (rejected: overkill for current scale, coordination complexity)

---

## üÖë Implementation Tasks

### Task 9.2.a ‚Äî Idempotency Entity

**Deliverable:** JPA Entity for `processed_events` table

```java
package com.triagemate.triage.idempotency;

import jakarta.persistence.*;
import java.time.Instant;

@Entity
@Table(name = "processed_events")
public class ProcessedEvent {

    @Id
    @Column(name = "event_id", nullable = false, length = 255)
    private String eventId;

    @Column(name = "processed_at", nullable = false)
    private Instant processedAt;

    @Column(name = "decision_id", nullable = false, length = 255)
    private String decisionId;

    // Default constructor for JPA
    protected ProcessedEvent() {}

    public ProcessedEvent(String eventId, String decisionId, Instant processedAt) {
        this.eventId = eventId;
        this.decisionId = decisionId;
        this.processedAt = processedAt;
    }

    // Getters
    public String getEventId() { return eventId; }
    public Instant getProcessedAt() { return processedAt; }
    public String getDecisionId() { return decisionId; }
}
```

**Acceptance:**
- Table auto-created in test profile (`ddl-auto: create-drop`)
- Table validated (not created) in dev profile (`ddl-auto: validate`)
- Unique constraint enforced by primary key
- No manual SQL required in tests
- Entity package follows hexagonal architecture conventions

---

### Task 9.2.b ‚Äî Repository Layer

**Deliverable:** Spring Data JPA repository interface

```java
package com.triagemate.triage.idempotency;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ProcessedEventRepository 
        extends JpaRepository<ProcessedEvent, String> {
    // Spring Data provides:
    // - existsById(String eventId)
    // - save(ProcessedEvent event)
    // No custom queries needed initially
}
```

**Acceptance:**
- Repository injected successfully in service layer
- `existsById()` method available for duplicate detection
- `save()` method available for persistence
- No custom query implementation required
- Repository follows naming conventions

---

### Task 9.2.c ‚Äî Service Integration

**Deliverable:** Transactional idempotency guard implementation

**Flow:**
```
Kafka Listener receives event
    ‚Üì
Validate Event (existing validation)
    ‚Üì
Check if eventId exists in DB
    ‚Üì
If exists ‚Üí skip processing (log idempotent hit)
    ‚Üì
If not ‚Üí persist event + emit decision (atomic transaction)
```

**Implementation Pattern:**

```java
@Service
@Transactional
public class DatabaseIdempotencyGuard implements IdempotencyGuard {

    private final ProcessedEventRepository repository;

    public DatabaseIdempotencyGuard(ProcessedEventRepository repository) {
        this.repository = repository;
    }

    @Override
    public boolean shouldProcess(String eventId) {
        boolean exists = repository.existsById(eventId);
        if (exists) {
            log.info("Duplicate event detected: {}", eventId);
            return false;
        }
        return true;
    }

    @Override
    public void markProcessed(String eventId, String decisionId) {
        ProcessedEvent event = new ProcessedEvent(
            eventId, 
            decisionId, 
            Instant.now()
        );
        repository.save(event);
        log.debug("Marked event {} as processed", eventId);
    }
}
```

**Transaction Boundary:**
```java
@Transactional
public void handleEvent(InputEvent event) {
    // 1. Check idempotency
    if (!idempotencyGuard.shouldProcess(event.getEventId())) {
        return; // Already processed
    }

    // 2. Make decision
    Decision decision = decisionService.makeDecision(event);

    // 3. Persist idempotency record
    idempotencyGuard.markProcessed(
        event.getEventId(), 
        decision.getDecisionId()
    );

    // 4. Emit decision event
    decisionRouter.route(decision);
    
    // Transaction commits here - atomic guarantee
}
```

**Critical Design Point:**
- **MUST** persist idempotency record BEFORE emitting decision event
- If transaction rolls back, no decision event is emitted
- Prevents duplicate decisions from partial failures

**Acceptance:**
- Duplicate event does NOT produce duplicate decision
- Restart does NOT lose idempotency memory
- Transaction rollback prevents decision emission
- Clear logging for idempotent hits
- No synchronized blocks or in-memory maps

---

### Task 9.2.d ‚Äî Remove In-Memory Idempotency

**Deliverable:** Clean removal of Phase 8.x stopgap implementation

**Files to modify:**
- Remove `EventIdIdempotencyGuard` (or mark as deprecated)
- Remove `ConcurrentHashMap` based storage
- Remove `@Configuration` wiring for in-memory guard
- Update dependency injection to use `DatabaseIdempotencyGuard`

**Acceptance:**
- No `synchronized` blocks in idempotency code
- No `ConcurrentHashMap` usage
- All unit tests updated to reflect database-backed implementation
- No dead code remaining

---

### Task 9.2.e ‚Äî Deserialization Hardening

**Deliverable:** Enhanced error handling for malformed messages

Already using `ErrorHandlingDeserializer`. Now enforce:
- **Null payload detection** ‚Äî reject before processing
- **Malformed JSON isolation** ‚Äî log and skip without crash
- **Consumer resilience** ‚Äî no listener container shutdown

**Implementation:**

```java
@KafkaListener(topics = "triagemate.ingest.input-received.v1")
public void onInputEvent(
    @Payload(required = false) InputEvent event,
    @Header(value = KafkaHeaders.RECEIVED_KEY, required = false) String key,
    @Header(value = KafkaHeaders.RECEIVED_TOPIC) String topic,
    @Header(value = KafkaHeaders.OFFSET) long offset
) {
    if (event == null) {
        log.error(
            "Null payload received: topic={}, offset={}, key={}", 
            topic, offset, key
        );
        // Offset will advance - message is effectively skipped
        return;
    }

    try {
        processEvent(event);
    } catch (Exception e) {
        log.error(
            "Failed to process event: eventId={}, topic={}, offset={}", 
            event.getEventId(), topic, offset, e
        );
        // Currently: log and skip
        // Future: send to DLT
    }
}
```

**Acceptance:**
- Malformed JSON does not crash listener
- Null payloads are detected and logged
- Offset advances for unprocessable messages
- Consumer container remains alive
- Clear error logs for debugging

---

## üÖí Verification Plan

### Automated Integration Tests

#### Test 9.2.1 ‚Äî Valid Event Flow
```java
@SpringBootTest
@Testcontainers
class ValidEventFlowTest {
    
    @Test
    void validEvent_isProcessed_andPersisted() {
        // Given: Valid input event
        InputEvent event = createValidEvent("evt-001");
        
        // When: Event is consumed
        kafkaTemplate.send("triagemate.ingest.input-received.v1", event);
        
        // Then: Decision is emitted
        ConsumerRecord<String, Decision> decision = 
            pollDecision(timeout = 5.seconds);
        assertThat(decision.value().getEventId()).isEqualTo("evt-001");
        
        // And: Database row exists
        Optional<ProcessedEvent> record = 
            repository.findById("evt-001");
        assertThat(record).isPresent();
        assertThat(record.get().getDecisionId())
            .isEqualTo(decision.value().getDecisionId());
    }
}
```

**Acceptance:**
- Event consumed successfully
- Decision emitted to output topic
- Database row inserted with correct `event_id` and `decision_id`
- Test uses Testcontainers (no manual DB setup)

---

#### Test 9.2.2 ‚Äî Duplicate Event Detection
```java
@Test
void duplicateEvent_isDetected_noDuplicateDecision() {
    // Given: Event processed once
    InputEvent event = createValidEvent("evt-dup-001");
    kafkaTemplate.send("triagemate.ingest.input-received.v1", event);
    pollDecision(timeout = 5.seconds); // Consume first decision
    
    // When: Same event sent again
    kafkaTemplate.send("triagemate.ingest.input-received.v1", event);
    
    // Then: No second decision emitted
    assertThat(pollDecision(timeout = 2.seconds)).isNull();
    
    // And: Only ONE database row exists
    long count = repository.count();
    assertThat(count).isEqualTo(1);
}
```

**Acceptance:**
- First event produces decision + DB row
- Second identical event produces NO decision
- Only 1 row in `processed_events` table
- Logs contain "Duplicate event detected" message

---

#### Test 9.2.3 ‚Äî Restart Persistence
```java
@Test
void afterRestart_duplicateStillDetected() {
    // Given: Event processed and persisted
    InputEvent event = createValidEvent("evt-restart-001");
    kafkaTemplate.send("triagemate.ingest.input-received.v1", event);
    pollDecision(timeout = 5.seconds);
    
    // When: Application context refreshed (simulates restart)
    context.close();
    context = new SpringApplicationBuilder(...)
        .profiles("test")
        .run();
    
    // And: Same event sent again
    kafkaTemplate.send("triagemate.ingest.input-received.v1", event);
    
    // Then: Still detected as duplicate
    assertThat(pollDecision(timeout = 2.seconds)).isNull();
    assertThat(repository.existsById("evt-restart-001")).isTrue();
}
```

**Acceptance:**
- Idempotency survives application restart
- No in-memory state required
- Database is source of truth

---

#### Test 9.2.4 ‚Äî Malformed Payload Resilience
```java
@Test
void malformedJson_doesNotCrashConsumer() {
    // Given: Malformed JSON payload
    String malformedJson = "{\"eventId\":\"broken\",\"payload\":INVALID}";
    
    // When: Malformed message sent
    ProducerRecord<String, String> record = new ProducerRecord<>(
        "triagemate.ingest.input-received.v1",
        malformedJson
    );
    kafkaTemplate.send(record);
    
    // Then: Consumer remains alive
    await().atMost(3.seconds).untilAsserted(() -> {
        // Send valid event to prove consumer still works
        InputEvent validEvent = createValidEvent("evt-after-malformed");
        kafkaTemplate.send("triagemate.ingest.input-received.v1", validEvent);
        
        Decision decision = pollDecision(timeout = 2.seconds);
        assertThat(decision).isNotNull();
    });
}
```

**Acceptance:**
- Malformed JSON does not crash listener
- Consumer continues processing subsequent valid events
- Error logged with topic/offset information
- No decision emitted for malformed message

---

#### Test 9.2.5 ‚Äî Null Payload Handling
```java
@Test
void nullPayload_isDetected_andSkipped() {
    // Given: Message with null payload
    ProducerRecord<String, InputEvent> record = new ProducerRecord<>(
        "triagemate.ingest.input-received.v1",
        "some-key",
        null  // Explicit null
    );
    
    // When: Null payload sent
    kafkaTemplate.send(record);
    
    // Then: No decision emitted
    assertThat(pollDecision(timeout = 2.seconds)).isNull();
    
    // And: Error logged
    assertThat(logCapture.getMessages())
        .anyMatch(msg -> msg.contains("Null payload received"));
}
```

**Acceptance:**
- Null payloads detected before processing
- No NPE thrown
- Clear error log message
- Consumer remains functional

---

### Manual Verification Checklist

| Step | Command | Expected Result |
|------|---------|-----------------|
| 1 | `docker compose up -d` | PostgreSQL + Kafka start |
| 2 | `./mvnw spring-boot:run -Dspring-boot.run.profiles=dev` | App starts, connects to DB |
| 3 | Send valid event via Kafka console producer | Decision emitted, DB row created |
| 4 | Send same event again | No duplicate decision, logs show "duplicate detected" |
| 5 | `docker compose restart triagemate-triage` | App restarts successfully |
| 6 | Send same event third time | Still detected as duplicate (persistence verified) |
| 7 | Check DB: `SELECT * FROM processed_events` | Row exists with correct `event_id` and `decision_id` |

---

## üÖì Done Criteria

Phase 9.2 is **DONE** when:

- ‚úÖ `processed_events` table exists and is auto-created in test profile
- ‚úÖ `ProcessedEvent` JPA entity created
- ‚úÖ `ProcessedEventRepository` created and injected
- ‚úÖ `DatabaseIdempotencyGuard` implementation complete
- ‚úÖ In-memory idempotency code removed (no `ConcurrentHashMap`, no `synchronized`)
- ‚úÖ Duplicate detection works across application restarts
- ‚úÖ All integration tests green:
    - Valid event flow test ‚úÖ
    - Duplicate event detection test ‚úÖ
    - Restart persistence test ‚úÖ
    - Malformed JSON resilience test ‚úÖ
    - Null payload handling test ‚úÖ
- ‚úÖ CI pipeline green (no test context wiring failures)
- ‚úÖ Deserialization hardening complete (null checks, error isolation)
- ‚úÖ `application-test.yml` includes proper datasource configuration
- ‚úÖ No regression in existing unit tests
- ‚úÖ `README.md` updated with:
    - Database schema documentation
    - Idempotency behavior explanation
    - Troubleshooting section for DB connection issues
- ‚úÖ ADR-005 updated with implementation notes
- ‚úÖ `phase9.md` updated with Phase 9.2 completion
- ‚úÖ Tag `v0.9.2` created and pushed

---

## üì¶ Dependencies

### Maven Dependencies (Already Added in 9.1)

```xml
<!-- PostgreSQL Driver -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- Spring Boot Starter Data JPA -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- Testcontainers PostgreSQL (test scope) -->
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>postgresql</artifactId>
    <scope>test</scope>
</dependency>

<!-- JUnit Jupiter (for @SpringBootTest) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

**No new dependencies required** ‚Äî Phase 9.1 infrastructure is sufficient.

---

## üîó Related Documentation

- [ADR-005: Durable Idempotency Strategy](./adr/ADR-005-durable-idempotency.md)
- [Phase 8.1: In-Memory Idempotency (deprecated)](./Phase-8.1-InMemory-Idempotency.md)
- [Phase 9.1: PostgreSQL Runtime](./Phase-9.1-PostgreSQL-Runtime.md)
- [Structured Coding Process v3.0](./structured-coding-process-v3.md)
- [Hexagonal Architecture Guidelines](./hexagonal-architecture.md)

---

## ‚ö†Ô∏è Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|-----------|
| **Race condition on concurrent consumers** | Medium | Database primary key constraint provides atomic uniqueness guarantee |
| **Transaction rollback emits duplicate decision** | High | **CRITICAL:** Persist idempotency record BEFORE emitting decision event |
| **Test flakiness (timing issues)** | Medium | Use Awaitility for async assertions, increase timeouts if needed |
| **Performance bottleneck on DB writes** | Low (current scale) | Add index on `processed_at` if needed for cleanup queries later |
| **Orphaned DB records (decision never emitted)** | Low | Transaction boundary ensures atomicity; future: add cleanup job |
| **application-test.yml missing datasource** | High | **IMMEDIATE FIX REQUIRED:** Add Testcontainers JDBC URL to test profile |

---

## üö® Critical Issues to Address

### Issue 9.2.CI-1 ‚Äî Test Profile Missing Datasource Configuration

**Symptom:**
```
Failed to configure a DataSource: 'url' attribute is not specified
```

**Root Cause:**
`application-test.yml` does not provide datasource configuration for test profile.

**Fix Required:**

```yaml
# triagemate-triage/src/test/resources/application-test.yml
spring:
  datasource:
    url: jdbc:tc:postgresql:16-alpine:///triagemate
    driver-class-name: org.testcontainers.jdbc.ContainerDatabaseDriver
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: false
```

**Verification:**
```bash
./mvnw clean test -pl triagemate-triage
```

**Acceptance:**
- All integration tests load ApplicationContext successfully
- No "Failed to determine a suitable driver class" errors
- Testcontainers PostgreSQL starts automatically

---

## üìù Implementation Checklist

### Phase A: Design Validation
- [x] Confirm table schema design
- [x] Confirm transactional boundary approach
- [x] Review ADR-005 alignment
- [ ] **FIX:** Add `application-test.yml` with datasource config

### Phase B: Entity & Repository
- [ ] Create `ProcessedEvent` JPA entity
- [ ] Create `ProcessedEventRepository` interface
- [ ] Verify table auto-creation in test profile
- [ ] Add unit tests for entity validation

### Phase C: Service Integration
- [ ] Implement `DatabaseIdempotencyGuard`
- [ ] Wire into Kafka listener flow
- [ ] Ensure transaction boundary wraps persistence + emission
- [ ] Remove `EventIdIdempotencyGuard` (in-memory)
- [ ] Remove `ConcurrentHashMap` usage
- [ ] Update dependency injection configuration

### Phase D: Deserialization Hardening
- [ ] Add null payload detection
- [ ] Add malformed JSON error handling
- [ ] Update Kafka listener with error isolation
- [ ] Add logging for skipped messages

### Phase E: Integration Tests
- [ ] Valid event flow test
- [ ] Duplicate event detection test
- [ ] Restart persistence test
- [ ] Malformed JSON resilience test
- [ ] Null payload handling test
- [ ] All tests green locally
- [ ] All tests green in CI

### Phase F: Documentation
- [ ] Update `README.md` with idempotency section
- [ ] Document database schema
- [ ] Add troubleshooting guide
- [ ] Update ADR-005 with implementation notes
- [ ] Update `phase9.md` with Phase 9.2 completion

### Phase G: Completion
- [ ] All acceptance criteria met
- [ ] Code review approval
- [ ] CI green
- [ ] Manual verification checklist complete
- [ ] Tag `v0.9.2` created and pushed
- [ ] Announce completion in project channel

---

## üéØ Success Metrics

Phase 9.2 success measured by:

1. **Zero in-memory state** ‚Äî no `ConcurrentHashMap`, no `synchronized` blocks
2. **Restart resilience** ‚Äî duplicate detection survives application crashes
3. **CI stability** ‚Äî all integration tests green, no flakiness
4. **Clear error handling** ‚Äî malformed messages logged, not crashed
5. **Database truth** ‚Äî `processed_events` table is single source of idempotency truth

---

**Document Version:** 1.0  
**Last Updated:** 2026-02-23  
**Status:** Design phase complete ‚Äî BLOCKED on test datasource configuration fix  
**Next Action:** Fix `application-test.yml` datasource config, then proceed to entity implementation